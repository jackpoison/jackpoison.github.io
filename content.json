{"meta":{"title":"Jack's Little Ship","subtitle":null,"description":null,"author":"Jackpoison","url":"https://jackpison.tk"},"pages":[{"title":"all-archives","date":"2018-05-04T01:11:50.048Z","updated":"2018-05-04T01:11:50.048Z","comments":false,"path":"all-archives/index.html","permalink":"https://jackpison.tk/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2018-05-04T01:11:50.048Z","updated":"2018-05-04T01:11:50.048Z","comments":false,"path":"all-categories/index.html","permalink":"https://jackpison.tk/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2018-05-04T01:11:50.048Z","updated":"2018-05-04T01:11:50.048Z","comments":false,"path":"all-tags/index.html","permalink":"https://jackpison.tk/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生成函数","slug":"generating-function","date":"2018-03-08T11:45:36.000Z","updated":"2018-05-04T01:51:21.379Z","comments":true,"path":"Mathematics/generating-function/","link":"","permalink":"https://jackpison.tk/Mathematics/generating-function/","excerpt":"定义 对于数列\\(\\{f_n\\}\\)，我们定义\\(\\tilde F(x)=\\sum^\\infty_{i=0}f_ix^i\\)，并称\\(\\tilde F(x)\\)为数列\\(\\{f_n\\}\\)的生成函数。 定义就这么点。 从这个定义可以看出，生成函数实际上就是在描述一个序列（其实你也可以把它当做集合）。 但实际应用中，生成函数可以比更加灵活，我们可以利用生成函数来表示状态集合，利用生成函数的性质来计数，求解数列等。","text":"定义 对于数列\\(\\{f_n\\}\\)，我们定义\\(\\tilde F(x)=\\sum^\\infty_{i=0}f_ix^i\\)，并称\\(\\tilde F(x)\\)为数列\\(\\{f_n\\}\\)的生成函数。 定义就这么点。 从这个定义可以看出，生成函数实际上就是在描述一个序列（其实你也可以把它当做集合）。 但实际应用中，生成函数可以比更加灵活，我们可以利用生成函数来表示状态集合，利用生成函数的性质来计数，求解数列等。 生成函数的运算 对于\\(\\{a_n\\}\\)我们记\\(\\tilde A(x)\\)为它对应的生成函数。 即用小写字母表示序列，大写字母表示生成函数。 加减乘常数 \\[ \\tilde A(x)=\\alpha\\tilde B(x)\\pm \\beta\\tilde C(x)\\\\ \\Leftrightarrow a_n=\\alpha b_n\\pm \\beta c_n \\] 偏移 \\[ \\tilde A(x)=x^l\\tilde B(x)\\\\\\Leftrightarrow a_n=b_{n-l} \\] 生成函数乘法(卷积) \\[ \\tilde A(x)=\\tilde B(x) * \\tilde C(x)\\\\ \\Leftrightarrow a_n=\\sum_{i+j=n}b_i*c_j \\] 实际上，这个乘法还可以定义为其他的卷积，比如异或卷积，与卷积，或卷积以及其他，只要能快速计算，在OI中就比较很意义。 假如我的卷积中有一个组合数系数怎么办呢？ 即 \\[ c_n=\\sum^n_{i=0}\\binom{n}{i}a_ib_{n-i} \\] 我们就要用到指数型生成函数 \\[ \\tilde C(x)=\\sum^\\infty_{i=0}\\frac{c_i}{i!}x^i \\] 你会惊奇地发现，这样卷起来之后刚好满足条件。 求导和积分 \\[ \\tilde A(x)=\\tilde B&#39;(x)\\Leftrightarrow a_n=(n+1)b_{n+1}\\\\ \\tilde A(x)=\\int \\tilde B(x)dx\\Leftrightarrow a_n=\\frac{b_{n-1}}{n} \\] 这种操作多用于将你的序列乘或除下标的时候。 指数和取对 \\[ exp(\\tilde F(x))=\\sum^\\infty_{i=0}\\frac{\\tilde F^{(i)}(x)}{i!}\\\\ ln(\\tilde F(x))=\\sum^\\infty_{i=1}\\frac{\\tilde F^{(i)}(x)}{i} \\] 该操作的对序列的意义不大明确，但可以用来求解包含生成函数的方程。 具体实现时采用 倍增+FFT，暂不进行讨论。 开方与求逆 实际上这也没什么实际意义，通常都是解生成函数的中间操作。 对形如\\(\\tilde G(x)=(1+\\tilde F(x))^\\alpha,\\alpha\\in \\mathbb{R}\\)，我们可以利用广义二项式定理展开成 \\[ \\tilde G(x)=\\sum^\\infty_{i=0}\\frac{\\alpha^{\\underline{i}}}{i!}\\tilde F^{(i)}(x) \\] 其中\\(\\alpha^{\\underline i}=\\alpha(\\alpha-1)\\cdots(\\alpha-i+1)\\)， 特别地\\(\\frac{(-n)^{\\underline{i}}}{i!}=\\binom{n+i-1}{i}(-1)^{i}\\) 取模 生成函数的推导中实际上很少采用取模操作。 但由于计算机能处理的范围并不是我们求和的\\(0\\rightarrow\\infty\\)，我们在具体应用中经常使用\\((mod~x^n)\\)这样的操作来便于实现，在这里就不具体讨论了。 总之，生成函数为我们提供了非常舒服的运算方式，大部分时候都可以让我们只用关心转移或递推，得到关系式之后扔给计算机求解。 常见的生成函数 \\[ \\begin{aligned} \\frac{1}{1-x}&amp;=\\sum^\\infty_{i=0}x^i\\\\ \\frac{1}{(1-x)^r}&amp;=\\sum\\binom{r+i-1}{i}x^i,r\\in\\mathbb{N^*}\\\\ \\frac{1}{(1-x)^2}&amp;=\\sum^\\infty_{i=0}(i+1)x^i=(\\frac{1}{1-x})&#39;\\\\ ln(\\frac{1}{1-x})&amp;=\\sum^\\infty_{i=1}\\frac{1}{i}x^i=\\int\\frac{1}{1-x}dx\\\\ exp(x)&amp;=\\sum^\\infty_{i=0}\\frac{x^i}{i!}\\\\ ln(1+x)&amp;=\\sum^\\infty_{i=1}\\frac{(-1)^{k+1}}{k}x^k \\end{aligned} \\] 但这些有什么用呢？举几个例子。 假如我要求调和级数（\\(H_n=\\sum_{i=1}^n\\frac{1}{i}\\)），我就可以拿出\\(\\{\\frac{1}{n}\\}\\)的生成函数\\(ln(\\frac{1}{1-x})\\)，给它乘上一个\\(\\frac{1}{1-x}\\)即可。即 \\[ [x^n](\\frac{1}{1-x}ln(\\frac{1}{1-x}))=H_i \\] 假如我要求将某个正整数拆分成若干个正整数之和的方案数，那么我就可以设生成函数\\(f_n(x)=\\sum^\\infty_{k=0}x^{kn}=\\frac{1}{1-x^n}​\\)，来表示正整数\\(n​\\)选了\\(k​\\)个，那答案的生成函数就可以表示为 \\[ \\begin{aligned} &amp;F(x)=\\prod^\\infty_{n=1}f_n(x)=\\prod^\\infty_{n=1}\\frac{1}{1-x^n}\\\\&amp; 其中[x^n]F(x)为n的划分数。 \\end{aligned} \\] 求解线性递推 设\\(a_n=b_1a_{n-1}+b_2a_{n-2}+\\cdots+b_ka_{n-k}\\)为\\(k\\)阶线性递推数列 那么根据前面的偏移操作和乘常数的操作，有 \\[ \\begin{equation} a_k=b_1a_{k-1}+b_2a_{k-2}\\cdots+b_ka_0\\\\ a_{k+1}=b_1xa_k+b_2a_{k-1}\\cdots+b_ka_1\\\\ \\end{equation} \\] \\[ \\begin{aligned} \\tilde A(x)=&amp;(\\tilde A(x)-\\sum^{k-2}_{i=0}a_ix^i)b_1x^1\\\\ +&amp;(\\tilde A(x)-\\sum^{k-3}_{i=0}a_ix^i)b_2x^2\\\\ +&amp;\\cdots\\\\ +&amp;\\tilde A(x)b_kx^k+\\sum^{k-1}_{i=0}a_ix^i \\end{aligned} \\] 将\\(\\tilde A(x)\\)移到一边，就有 \\[ \\tilde A(x)(1-\\sum^{k}_{i=1}b_ix^i)=\\sum^{k-1}_{i=0}a_i(1-\\sum_{j=1}^{k-i-1}b_jx^j) \\] 得 \\[ \\tilde A(x)=\\frac{\\sum^{k-1}_{i=0}a_i(1-\\sum_{j=1}^{k-i-1}b_jx^j)}{1-\\sum^{k}_{i=1}b_ix^i} \\] 可使用多项式求逆解决。 题外话 为什么会有特征根呢？ 我们可以发现答案的分母就相当于将特征根方程\\(x^k=\\sum^k_{i=1}b_ix^{k-i}\\)的系数颠倒，由代数基本定理可知\\(1-\\sum^{k}_{i=1}b_ix^i=\\prod_{i=1}^k(1-\\lambda_ix)\\)，其中\\(\\lambda_i\\)是特征根。可以将答案写为\\(\\tilde A(x)=\\sum^k_{i=1}\\frac{C_i}{1-\\lambda_ix}\\)的形式，其中\\(C_i\\)为常数，由之前的展开就可以知道\\([x^n]\\tilde A(x)=\\sum^k_{i=1}{C_i\\lambda_i^n}\\)。 此处应有严谨证明，但时间有限，只有先挖坑了。 求解卷积递推 例 The Child And Binary Tree 有一个含有 \\(n\\) 个元素的正整数集合 \\(S={c_1,c_2,⋯,c_n}\\)，我们称一个节点带权的有根二叉树是好的，当且仅当对于每个节点 \\(v\\)，\\(v\\) 的权值在 \\(S\\) 内，并且我们称这棵树的权值为所有节点的权值和 现在给出一个正整数 \\(m\\)，你要计算出对于所有正整数 \\(1≤s≤m\\)，有多少不同的好的二叉树满足它的权值是 \\(s\\) 答案对 \\(998244353(7×17×223+1,一个质数)\\) 取模，其中 \\(1≤n,m,c_i≤10^5\\) 题目链接：Codeforces-438E、BZOJ-3625、NKOJ-3218 这道题就可以体现生成函数的灵活性。 考虑函数\\(\\tilde F(x)\\)，它表示所有的二叉树。\\([x^n]\\tilde F(x)\\)表示权值和为\\(n\\)的不同的二叉树个数。为了方便，我们定义\\([x^0]\\tilde F(x)=1\\)，即存在空树。 我们想一想我们的二叉树是如何生成的。 它有一个根节点，根节点有左右子树，那么递推（递归？）关系就出来了。 \\[ \\tilde F(x)=\\tilde F(x)(\\sum x^{s_i})\\tilde F(x)+1 \\] 左子树的方案卷上根的方案再卷上右子树的方案，再加上空树的方案。 我们生成函数的性质很好，它几乎支持所有运算，所以就可以解得 \\[ \\tilde S(x)=\\sum x^{s_i}\\\\ \\tilde F(x)=\\frac{1-\\sqrt{1-4\\tilde S(x)}}{2\\tilde S(x)} \\] 为什么不取+号呢？ 由于我们具体操作的时候，多项式取逆必须要满足常数项不为0，但显然我们的\\(\\tilde S(x)\\)没有常数项，所以必须要求上面的式子没有常数项，以约掉公共的\\(x^i\\)，以便求逆。假如对多项式开方熟悉一点就会知道上面开方出来的常数项为1，我们要减掉。就是这样。 例 括号序列计数(n=1) 题面在此：vijos,nkoj,bzoj 我们只考虑(n=1)的情况，即告诉你左括号，右括号，空格的种类为\\(a,b,c\\)，问你长度为\\(len\\)的括号序列的个数。 这个问题显然可以用Catalan数和卷积解决，但我们可以试着用生成函数思考。 以下可能会出现生成函数符号与集合混用的情况，请大家感性理解。 我们要求长度为\\(len\\)的括号序列的个数，显然我们要求一个生成函数来表示所有的合法括号序列，设它为\\(\\tilde F(x)\\),\\([x^n]\\tilde F(x)\\)为长度为\\(n\\)的合法括号序列种数。但是我们直接这样的话，似乎不是很好转移。 不好转移，那我们就多设几个生成函数呗。 设\\(A(x)\\)为所有外面套了一个括号的括号序列的生成函数，例如(())\\(\\in A\\)，但()()\\(\\notin A\\)。 设\\(B(x)\\)为仅由空格组成的合法序列，例如{|,#,##,###,…}，|表示空状态。 那么有 \\[ B(x)=\\frac{1}{1-cx}\\\\ A(x)=axF(x)bx=abx^2F(x)\\\\ F(x)=F(x)A(x)B(x)+B(x)\\\\ F(x)=F^2(x)abx^2B(x)+B(x)\\\\ F(x)=\\frac{1-\\sqrt{1-4abx^2B^2(x)}}{2abx^2B(x)} \\] 多项式开方，求逆一股脑弄上去就好了。 当n=2时，上面的\\(F,A,B\\)就可以变成2x2的矩阵，但是似乎这样并解不出来，尬。 实际上这两个递推的解形式都是Catalan-like Catalan数的生成函数为\\(C(x)=\\frac{1-\\sqrt{1-4x}}{2x}\\) 关于概率的计算 用生成函数来求解概率问题在有些时候往往有奇效。 设某个问题的状态可以又一些小状态\\(\\{s_i\\}\\)的序列表示，其中出现\\(s_i\\)的概率为\\(p_i\\)。 记所有当前所有状态的集合（生成函数）为\\(S\\)，那么 \\(S&#39;=S(\\sum p_is_i)\\) \\(S&#39;\\)中每一项的系数都表示从\\(S\\)集合中再走一步得到某个状态的概率\\(p\\)。 我们将\\(s_i\\)变成一些与\\(x\\)有关的东西，就可以统计一些信息。 例 一道有趣的硬币游戏 题目链接：NKOJ 给你一些长度为m的HT序列，不断抛硬币，出现上述序列中的一个就停止，求以每种序列停止的概率。 这道题的推导可以是将生成函数和集合结合在一起。 我们设\\(N\\)是没有人赢的状态的集合，把他化为生成函数的感觉就是把它的每个状态前面乘上一个概率系数再加起来，但出现HT的概率是已知的，我们可以等会再加进去。 设\\(A_i\\)为第\\(i\\)个串\\(S_i\\)的赢的状态集合。考虑走了一步，就有 \\[ |+N(H+T)=N+\\sum A_i \\] 其中“|”表示空状态。 但是只有这个关系式还不够，我们要想想他们之间更多的关系。 举个例子，\\(S_1=\\)HTHT，\\(S_2\\)=HTTT。 我们想一想，直接给\\(N\\)接上\\(S_2\\)，得到的可能是\\(A_2\\)，但也可能先是\\(A_1\\)，再加上一段。 e.g. origin=HT，modified=HTHTTT 假如我们考虑一下这些前后缀重合的状态，就可以发现如下等式 \\[ \\begin{aligned} N\\cdot HTTT&amp;=A_1\\cdot TT+A_2\\\\ N\\cdot HTHT&amp;=A_1 \\end{aligned} \\] 现在我们把\\(H\\)和\\(T\\)都换成\\(\\frac{x}{2}\\)，再令\\(x=1\\)，根据我们的定义，\\(A_i(1)\\)就可以表示出现\\(A_i\\)中状态的概率。 我们在\\(x=1\\)的情况下解方程，就可以得到每种序列赢的概率。 一些鬼畜的计数问题 例 n个节点的无标号有根有向树个数(source: TAOCP) RT. 有向有根树的定义为 \\[ \\forall v \\in V,\\exists one~and~only~one~path~from~v~to~root \\] 设每答案为\\(a_n\\)。 当\\(n=1\\)时，显然\\(a_1=1\\)。 当\\(n&gt;1\\)时，显然\\(root\\)有一些奇奇怪怪的子树。 我们假设大小为\\(j\\)的子树有\\(c_j\\)个，这里有\\(\\binom{c_j+a_j-1}{c_j}\\)种方案（隔板法，将\\(c_j\\)划分成\\(a_j\\)块，可以为空）。 \\[ a_n=\\sum_{c_1+2c_2+\\cdots=n-1}\\binom{c_1+a_1-1}{c_1}\\binom{c_2+a_2-1}{c_2}\\cdots\\binom{c_{n-1}+a_{n-1}+1}{c_{n-1}} \\] 根据我们前面的公式 \\[ \\sum^\\infty_{i=0}{\\binom{i+k-1}{i}}x^{ir}=\\frac{1}{(1-x^r)^k} \\] 有 \\[ A(x)=\\frac{x}{(1-x)^{a_1}(1-x^2)^{a_2}\\cdots} \\] 如何解？ 取对之后，有 \\[ \\begin{aligned} ln~A(x)&amp;=-\\sum_{i=1}^\\infty{a_i}{ln(1-x^i)}+ln(x)\\\\ &amp;=-\\sum_{i=1}^{\\infty}a_i\\sum_{j=1}^\\infty\\frac{(-1)^{j+1}(-x^i)^j}{j}+ln(x)\\\\ &amp;=\\sum_{i=1}^\\infty a_i\\sum^\\infty_{j=1}\\frac{x^{ij}}{j}+ln(x)\\\\ &amp;=\\sum_{i=1}^\\infty \\frac{A(x^i)}{i}+ln(x) \\end{aligned} \\] 即 \\[ A(x)=x\\cdot exp(\\sum^\\infty_{i=1}\\frac{A(x^i)}{i}) \\] 两边同时求导，有 \\[ \\begin{aligned} A&#39;(x)=\\frac{A(x)}{x}+A(x)\\cdot\\sum^\\infty_{i=1}A&#39;(x^i)x^{i-1}\\\\ x\\cdot A&#39;(x)=A(x)(1+\\sum_{i=1}^\\infty A&#39;(x^i)x^i) \\end{aligned} \\] 比较一波对应系数，我们可以发现 \\[ (n-1)a_nx^n=\\sum_{i+j*r=n}a_ix^ia_jjx^{jr},i,j,r\\ge1 \\] 于是乎 \\[ (n-1)a_n=\\sum_{i=1}^{n-1}ia_is_{n,i}\\\\ 其中s_{n,i}=\\sum_{n-i*r&gt;0}{a_{n-i*r}} \\] 我们就得到了一个\\(O(n^2log~n)\\)求\\(a_n\\)的较为优秀算法。 当我们把卷积换成异或卷积之后 很多时候，我们用生成函数求解问题，都不是在关注它是函数，而是寻找它表示的状态之间的关系。 生成函数的运算只是转移的另一种表达。 反正我们知道它能算！ 例 SDOI 2017 切树游戏 给出一棵无根树 \\(T\\)，节点从 \\(1\\) 到 \\(n\\) 编号，点 \\(i\\) 的权值为 \\(v_i\\)。定义一棵树的权值为树中所有点的权值异或起来的结果。 你想要在树上玩一个游戏。你会做 \\(m\\) 次以下两种操作： C x y：将 \\(v_x\\) 修改为 \\(y\\)。 Q k：询问 \\(T\\) 有多少棵非空的连通子树，满足这棵子树的权值为 \\(k\\)。输出模 10007。 如何求权值为\\(k\\)的子树个数？ 考虑把\\(T\\)变成有根树，对于一个联通子树\\(T&#39;\\)，我们令\\(T&#39;\\)深度最小(在\\(T\\)中)的为根，那么我们只需要考虑，某个点，它子树中，包括它，且权值为\\(k\\)的子树有多少。 假设我们现在\\(u\\)，记它的儿子为\\(s_i\\)，点\\(x\\)的答案为\\(F_x(z)\\)。 则\\(F_u(z)=z^{v_u}\\prod (z^0+F_{s_i}(z))\\)，在这里，我们就在考虑以每个儿子为根的联通子树是怎么选的。 要解决这道题，我们可以考虑轻重链剖分维护\\(\\sum_{u\\in T}F_u(z)\\)。 由于我们的乘法是异或卷积，实际实现中，我们可以维护\\(F(z)\\)FWT后点值(这样叫可能有些不妥)，我们生成函数的加减乘除可以换成对应点值的加减乘除，每次修改，就可以在每条重链的线段树上进行区间乘法/除法，注意模数较小，除数可能为0，要记下能被\\(mod\\)除几次。 但对于类似的问题，%%%ImmortalCO有一种动态DP的黑科技。 对每个点 \\(u\\) 定义一个向量 \\((F_u(z),H_u(z),z^0)\\) 。 \\(H_u(z)\\)是子树中的答案和。 对于每条重链上的，维护一下它对它对其重链上的父节点的贡献，这应该是一个和它的虚儿子有关的矩阵，我们只需要一个能支持单点修改，能高效维护矩阵积的数据结构，可以用线段树解决。 详情请见ImmortalCO’s Blog。 Reference ImmortalCO’s Blog Miskcoo’s Blog TAOCP Concrete Mathematics 《组合数学》","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://jackpison.tk/categories/Mathematics/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://jackpison.tk/tags/数学/"},{"name":"多项式","slug":"多项式","permalink":"https://jackpison.tk/tags/多项式/"},{"name":"生成函数","slug":"生成函数","permalink":"https://jackpison.tk/tags/生成函数/"}]},{"title":"NKOJ4487【集合计数】题解","slug":"NKOJ4487-sets-count","date":"2018-02-25T11:14:07.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"Solution/NKOJ4487-sets-count/","link":"","permalink":"https://jackpison.tk/Solution/NKOJ4487-sets-count/","excerpt":"题面在这里 一个有\\(N\\)个元素的集合有\\(2^N\\)个不同子集（包含空集），现在要在这\\(2^N\\)个集合中取出若干集合（至少一个），使得它们的交集的元素个数为\\(K\\)，求取法的方案数，答案模\\(1000000007\\)。（是质数喔~）","text":"题面在这里 一个有\\(N\\)个元素的集合有\\(2^N\\)个不同子集（包含空集），现在要在这\\(2^N\\)个集合中取出若干集合（至少一个），使得它们的交集的元素个数为\\(K\\)，求取法的方案数，答案模\\(1000000007\\)。（是质数喔~） 题目要求交集元素为\\(K\\)，我们可以考虑对我们选的\\(S_i\\)取补，有\\(|\\cup \\overline S_i|=N-K\\)。 我们只需要求并起来集合大小为\\(N-K\\)的选法有多少种。 我们设最后并起来得到的集合大小为\\(n\\)的方案数为\\(f(n)\\)，\\(Ans=\\binom{N}{N-K}f(N-K)\\)。 显然选的集合都是都是全集的子集，考虑直接乱选的方案数，有\\(2^{2^n}\\)种（每个集合都选或不选）。 考虑最后并起来的结果为\\(k​\\)，有 \\[ 2^{2^n}=\\sum^n_{k=0}\\binom{n}{k}f(k) \\] 二项式反演一下就有 \\[ f(n)=\\sum^n_{k=0}(-1)^{n-k}\\binom{n}{k}2^{2^n} \\] 预处理一下阶乘及其逆元，\\(2^{2^n}\\)直接平方平方就可以了，复杂度\\(O(N)\\)。 有个小细节，至少要选一个集合，要把空集的情况去掉，即\\(Ans-=[N==K]\\)。 附代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int N=1000009;int add(int a,int b) &#123;a+=b;a-=a&gt;=mod?mod:0;return a;&#125;int sub(int a,int b) &#123;a-=b;a+=a&lt;0?mod:0;return a;&#125;int mul(int a,int b) &#123;return 1LL*a*b%mod;&#125;int inv[N],n,K;int pows[N],Ans;int fact[N],finv[N];int C(int a,int b) &#123; return mul(fact[a],mul(finv[b],finv[a-b]));&#125;int main() &#123; int i; scanf(\"%d%d\",&amp;n,&amp;K); inv[1]=1; for(i=2;i&lt;=n;i++) inv[i]=mul(mod-mod/i,inv[mod%i]); fact[0]=finv[0]=1; pows[0]=2; for(i=1;i&lt;=n;i++) &#123; fact[i]=mul(fact[i-1],i); finv[i]=mul(finv[i-1],inv[i]); pows[i]=mul(pows[i-1],pows[i-1]); &#125; K=n-K; for(i=0;i&lt;=K;i++) &#123; Ans=((K-i&amp;1)?sub:add)(Ans,mul(C(K,i),pows[i])); &#125; Ans=mul(Ans,C(n,K)); printf(\"%d\\n\",Ans-(K==0));&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://jackpison.tk/categories/Solution/"}],"tags":[{"name":"Solution","slug":"Solution","permalink":"https://jackpison.tk/tags/Solution/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://jackpison.tk/tags/二项式反演/"}]},{"title":"二项式反演","slug":"binomial-transform","date":"2018-02-22T12:11:35.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"Mathematics/binomial-transform/","link":"","permalink":"https://jackpison.tk/Mathematics/binomial-transform/","excerpt":"反演概念 对于序列\\(\\{f_n\\},\\{g_n\\}\\)，我们可以找到一组关系，可以将\\(\\{f_n\\}\\)与\\(\\{g_n\\}\\)变换，这样的操作称为反演。 即\\(\\exists~\\{a_{n,i}\\},\\{b_{n,i}\\},s.t.\\) \\[ f_n=\\sum^n_{i=0}{a_{n,i}g_i} \\] \\[ g_n=\\sum^n_{i=0}b_{n,i}f_i \\] 两者等价。","text":"反演概念 对于序列\\(\\{f_n\\},\\{g_n\\}\\)，我们可以找到一组关系，可以将\\(\\{f_n\\}\\)与\\(\\{g_n\\}\\)变换，这样的操作称为反演。 即\\(\\exists~\\{a_{n,i}\\},\\{b_{n,i}\\},s.t.\\) \\[ f_n=\\sum^n_{i=0}{a_{n,i}g_i} \\] \\[ g_n=\\sum^n_{i=0}b_{n,i}f_i \\] 两者等价。 这里的\\(\\{a_{n,i}\\},\\{b_{n,i}\\}\\)我们是可以求出来的。 首先将\\(f_n\\)带入\\(g_n\\)就有： \\[ g_n=\\sum^n_{i=0}b_{n,i}\\sum^i_{j=0}a_{i,j}g_j \\] 非常熟练地交换求和号后： \\[ g_n=\\sum^n_{j=0}g_j\\sum^n_{i=j}b_{n,i}a_{i,j} \\] 对于这个形式，我们非常想猜想： \\[ \\sum^n_{i=j}b_{n,i}a_{i,j}=[n==j] \\] 实际上，这也是\\(\\{a_{n,i}\\},\\{b_{n,i}\\}\\)能构成反演的充要条件。 证明暂略（又在挖坑.jpg）。 常用的反演举例 Möbius 反演 \\[ \\begin{eqnarray} a_{n,d} &amp;=&amp; [d|n]\\\\ b_{n,d} &amp;=&amp; [d|n]\\mu(\\frac{n}{d})\\\\ f(n) &amp;=&amp;\\sum_{d|n}g(d)\\\\ g(n) &amp;=&amp; \\sum_{d|n}\\mu(\\frac{n}{d})f(d) \\end{eqnarray} \\] 二项式反演 \\[ \\begin{eqnarray} a_{n,i}&amp;=&amp;(-1)^i\\binom{n}{i}\\\\ b_{n,i}&amp;=&amp;(-1)^i\\binom{n}{i}\\\\ f(n)&amp;=&amp;\\sum_{i=0}(-1)^i\\binom{n}{i}g(i)\\\\ g(n)&amp;=&amp;\\sum_{i=0}(-1)^i\\binom{n}{i}f(i) \\end{eqnarray} \\] 是不是很优美？ 但我们平时用的多为另一种形式。 \\[ \\begin{eqnarray} a_{n,i}&amp;=&amp;\\binom{n}{i}\\\\ b_{n,i}&amp;=&amp;(-1)^{n-i}\\binom{n}{i}\\\\ f(n)&amp;=&amp;\\sum_{i=0}\\binom{n}{i}g(i)\\\\ g(n)&amp;=&amp;\\sum_{i=0}(-1)^{n-i}\\binom{n}{i}f(i) \\end{eqnarray} \\] 二项式应用举例 全错排问题 我们设\\(n\\)个元素的全错排有\\(f(n)\\)种。 直接求全错排方案数不好求，我们考虑任意排列的方案数，显然有\\(n!\\)种。 枚举每种排列中的不动点数量，有 \\[ n!=\\sum^n_{i=0}\\binom{n}{i}f(i) \\] 反演一下就可以得到 \\[ f(n)=\\sum^n_{i=0}(-1)^{n-i}\\binom{n}{i}i! \\] 就可以啦。 恰用\\(k\\)种颜色染色问题 \\(n\\)个格子排成一排，恰用\\(k\\)种颜色给这\\(n\\)个格子染色，相邻两个格子不共色，求方案数。 设答案为\\(f(n,k)\\)，先考虑放松条件，设不管“恰”的方案数为\\(g(n,k)\\)，易知\\(g(n,k)=k(k-1)^{n-1}\\)。 枚举每种方案中“恰”用的颜色数，有 \\[ g(n,k)=\\sum^k_{i=0}\\binom{k}{i}f(n,i) \\] 反演一下就可以得到 \\[ f(n,k)=\\sum^k_{i=0}(-1)^{k-i}\\binom{k}{i}i(i-1)^{n-1} \\] Over~ 一个Excited例子 假如你有一个数列\\(\\{a_n\\}\\)，它的通项是多项式，其次数最高项为\\(n^d\\)，现在给你\\(\\{a_0,\\ldots,a_d\\}\\)，询问\\(a_m\\)的值。 这题用二项式反演的话，是可以做到\\(O(d)\\)的！ 首先，我们可以发现，任意\\(d\\)阶多项式都可以表示成\\(\\sum^d_{i=0}{\\binom{n}{i}b_i}\\)的形式。 这个结论想想是很显然的，\\(\\binom{n}{i}\\)是\\(i\\)次多项式，如果按\\(i\\)从\\(d,d-1,\\ldots,0\\)的方式来确定\\(b_i\\)，每个\\(b_i\\)都是能唯一确定的。 有了这个结论，我们就可以考虑将\\(a_n\\)表示成如下形式： \\[ a_n=\\sum^n_{i=0}\\binom{n}{i}b_i \\] 其中高次项(\\(b_k,k&gt;d\\))补零。 运用二项式反演，我们可以得到： \\[ b_n=\\sum^n_{i=0}(-1)^{n-i}\\binom{n}{i}a_i \\] 我们需要知道\\(\\{b_k\\},k\\in\\{0,1,\\ldots,d\\}\\)，于是求上式只须求\\(\\{a_k\\},k\\in\\{0,1,\\ldots,d\\}\\)的值，而这是已知的（或很好求得的。 当然，直接这样预处理算出\\(b_n\\)的复杂度是\\(O(d^2)\\)的，我们还可以优化。 考虑直接将\\(b_n\\)带入\\(a_n\\)，有 \\[ a_n=\\sum^d_{i=0}\\binom{n}{i}b_i=\\sum^d_{i=0}\\binom{n}{i}\\sum^i_{j=0}(-1)^{i-j}\\binom{i}{j}a_j \\] 再次熟练地交换求和号 \\[ a_n=\\sum^d_{j=0}a_j\\sum^d_{i=j}\\binom{n}{i}\\binom{i}{j}(-1)^{i-j} \\] 用一个很简单的技巧 \\[ \\binom{n}{i}\\binom{i}{j}=\\binom{n}{j}\\binom{n-j}{i-j}\\\\ a_n=\\sum^d_{j=0}a_j\\sum^d_{i=j}\\binom{n}{j}\\binom{n-j}{i-j}(-1)^{i-j} \\] 证明很简单，可以打开用公式，也可以考虑其组合意义。 将\\(\\binom{n}{j}\\)提出来，变换一下下标 \\[ a_n=\\sum^d_{j=0}a_j\\binom{n}{j}\\sum^{d-j}_{i=0}\\binom{n-j}{i}(-1)^{i} \\] ​ 后面那一坨求个和就可以得到 \\[ a_n=\\sum^d_{j=0}a_j\\binom{n}{j}(-1)^{d-j}\\binom{n-j-1}{d-j} \\] (用\\(\\binom{i}{j}=\\binom{i-1}{j}+\\binom{i-1}{j-1}\\)带入即可) 我们还可以把它变换一下，但实际上已经差不多了。 我们要求的两个组合数数都可以递推求得。 但也可以再转换一下，有 \\[ \\begin{eqnarray} a_n&amp;=&amp;\\sum^d_{j=0}a_j(-1)^{d-j}\\frac{n!(n-j-1)!}{j!(n-j)!(d-j)!(n-1-d)!}\\\\ &amp;=&amp;\\sum^d_{j=0}a_j(-1)^{d-j}\\frac{n(n-1)\\cdots(n-d)}{j!(d-j)!(n-j)} \\end{eqnarray} \\] 预处理一下阶乘逆元和前后缀\\(\\Pi (n-i)\\)就可达到\\(O(d)\\)（模数是质数的话用线性递推，不用快速幂）。 ​ 一个更Excited例子 给定\\(A,B,C,p\\)，求 \\[ \\sum^A_{i=1}i^BC^i~(mod~p) \\] 回忆一下我们等比数列求和的公式 \\[ 1+q+q^2+\\cdots+q^n=\\frac{1-q^{n+1}}{1-q} \\] 实际上我们可以看出它是一个\\(\\alpha+\\beta q^n\\)的形式，其中\\(\\alpha,\\beta\\)是系数。 对于我们要求的和式，我们觉得结果肯定和\\(P(n),C^n\\)有关，其中\\(P(n)\\)为关于\\(n\\)的多项式。 比如\\(Sum(n)=P(n)*C^n\\)，我们就可以设数列\\(x_n=\\frac{Sum(n)}{C^n}\\)，用之前讲的方法来求。 但很不幸，当我用一个神奇的网站(Wolframalpha)找规律时，发现实际上\\(Sum(n)\\)的形式是这样的 \\[ Sum(n)=P(n)*C^n+Q_B(C) \\] 其中\\(Q_B(x)\\)是一个各项系数与\\(B\\)有关的多项式，长这样 \\[ \\begin{eqnarray} Q_1(x)&amp;=&amp;\\frac{x}{(1-x)^2}\\\\ Q_2(x)&amp;=&amp;\\frac{x(1+x)}{(1-x)^3}\\\\ Q_3(x)&amp;=&amp;\\frac{x(1+4x+x^2)}{(1-x)^4}\\\\ Q_4(x)&amp;=&amp;\\frac{x(1+11x+11x^2+x^3)}{(1-x)^5}\\\\ Q_3(x)&amp;=&amp;\\frac{x(1+26x+66x^2+26x^3+x^4)}{(-1+x)^6}\\\\ \\end{eqnarray} \\] 感觉很有规律对不对？ 那一坨多项式的系数对称的很好看有木有？ 但是该怎么算呢？ 机智的我上OEIS搜了一波，发现它居然叫\\(eulerian~numbers\\)！ 欧拉数，很强！而且它可以\\(O(B^2)\\)递推！ 于是这题就完了！ 很神奇对不对？ 更神奇的是，对\\(\\{1,2,\\ldots,n\\}\\)的一个排列\\(p\\)，记\\(f(p)=\\sum^{n-1}_{i=1}[p_i&lt;p_{i+1}]\\)，则\\(E(n,k)\\)就等于满足\\(f(p)=k\\)的排列数。是不是很Excited！（有同学想证明吗？欢迎填坑~） 完结散花~~","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://jackpison.tk/categories/Mathematics/"}],"tags":[{"name":"二项式反演","slug":"二项式反演","permalink":"https://jackpison.tk/tags/二项式反演/"},{"name":"数学","slug":"数学","permalink":"https://jackpison.tk/tags/数学/"}]},{"title":"PKU-WC","slug":"PKU-WC","date":"2018-01-29T14:50:47.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"Tour/PKU-WC/","link":"","permalink":"https://jackpison.tk/Tour/PKU-WC/","excerpt":"PKU WC的游记","text":"PKU WC的游记 Day-0 初到长沙，路上到处都是冰块。 风吹着很冷，但很舒服。 中午睡了一会儿，脑袋疼。 一点钟左右出去吃午饭，一家粉店，味道还不错。 从来没有遇到过肉饼蛋这种操作，不过真的很好吃。 冰天雪地里吃一碗热汤粉，感觉格外的温暖。 树上的雪开始融化，砸在头上，透心凉。 屋檐上挂着冰锥，晶莹剔透。 大概是在家乡永远也见不到的景象。 长郡中学。 第一眼感觉很寻常？ 还有孩子在上课，齐刷刷地穿着校服。 站在走廊上打量我们这群陌生来客。 下课了(铃声很吵？)， 教室里有人伸出手，轻抚窗台上的细雪。 学校的小湖里结了冰， 小桥上铺满了白雪。 很想遇到南开下雪的日子。 看雪花纷纷扬扬， 在阳光里闪耀。 学校外面有一家 知乎，茶也 是旁边茶颜悦色(sexy tea)旗下的茶饮店。 HE老板很大方，请了我们一人一杯。 红茶&amp;奶盖 味道很好 店面很漂亮，有那种水彩画的感觉。 用的纸杯，配上很好看的水彩，很美。 一开始以为不同的人杯子会不一样（虽然是一样的茶）。 但发现只有我的不一样。 唯一一杯冬日里的夏荷。 也许这就是某种小幸运？ 晚上去小吃街吃的韩国蛋包饭。 做饭的姐姐用番茄酱画了一直小熊。 小乖小乖的。 晚上打了一场模板赛（信心赛） 最后一题矩阵树，然而并没有写。 状压DP搞了一个半小时但果然T掉。 其实也还不错，不好也不坏。 希望明天加油吧。 （不知道远方的你现在在干什么呢） 附老代拍的照片一张","categories":[{"name":"Tour","slug":"Tour","permalink":"https://jackpison.tk/categories/Tour/"}],"tags":[{"name":"Tour?","slug":"Tour","permalink":"https://jackpison.tk/tags/Tour/"}]},{"title":"函数在给定区间上多项式近似的一种求法","slug":"polynomial-approximation","date":"2018-01-20T02:52:16.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"Mathematics/polynomial-approximation/","link":"","permalink":"https://jackpison.tk/Mathematics/polynomial-approximation/","excerpt":"引子 这个方法是原来乱翻线代书(Linear Agebra Done Right)看到的，当时就觉得非常厉害，但由于要求积分，一直不知道怎么实现。现在好了，多项式学了， Simpson 自适应积分也会了。闲来无事填个坑。","text":"引子 这个方法是原来乱翻线代书(Linear Agebra Done Right)看到的，当时就觉得非常厉害，但由于要求积分，一直不知道怎么实现。现在好了，多项式学了， Simpson 自适应积分也会了。闲来无事填个坑。 定义 \\(V\\)为所有\\(f(x):\\mathbb{R}\\to\\mathbb{R}\\)组成的集合 对\\(u,v\\in V\\)，定义其内积(Inner Product)为 \\[ &lt;u,v&gt;=\\int_a^b{u(x)v(x)dx} \\] \\((a,b)\\)就是给定的区间啦 对\\(u\\in V\\)，定义其模(Norm)为 \\[ ||u||=\\sqrt{&lt;u,u&gt;} \\] 对于\\(V\\)中一组向量(也就是元素)\\((u_1,u_2,\\ldots,u_n)\\)，我们称它为一组基，当且仅当，\\(\\forall v\\in V\\)，存在唯一的\\(a_1,a_2,...,a_n\\in R\\)，使得 \\[ v=a_1u_1+a_2u_2+\\ldots+a_nu_n \\] 对于一组基\\((u_1,u_2,\\ldots,u_n)\\)，我们称它为正交的，当且仅当 \\[ &lt;u_i,u_j&gt;=0,\\forall i,j \\in\\{1,\\ldots,n\\} \\] 对于一组基\\((u_1,u_2,\\ldots,u_n)\\)，我们称它为单位基，当且仅当 \\[ &lt;u_i,u_i&gt;=1,\\forall i \\in \\{1,\\ldots,n\\} \\] 性质 内积\\(&lt;u,v&gt;=\\int_a^bu(x)v(x)dx\\)，\\(a&lt;b\\)满足 交换律: \\(&lt;u,v&gt;=&lt;v,u&gt;\\) 线性: \\(&lt;u+v,w&gt;=&lt;u,w&gt;+&lt;v,u&gt;\\) \\(&lt;ku,v&gt;=k&lt;u,v&gt;, k\\in \\mathbb{R}\\) (非负性?忘了怎么说了): \\(&lt;u,u&gt;\\ge 0\\) (因而\\(||u||\\)总是有意义的) 若\\((u_1,u_2,...,u_n)\\)为一组单位正交基，则\\(\\forall v \\in V\\)，有 \\[ v=&lt;v,u_1&gt;u_1+&lt;v,u_2&gt;u_2+\\cdots+&lt;v,u_n&gt;u_n \\] Proof: 由\\((u_1,u_2,\\ldots,u_n)\\)为一组单位正交基，设\\(v=a_1u_1+a_2u_2+\\cdots+a_nu_n\\)，两边同时与\\(u_i\\)内积即有 \\[ &lt;v,u_i&gt;=&lt;a_1u_1,u_i&gt;+&lt;a_2u_2,u_i&gt;+\\cdots+&lt;a_nu_n,u_i&gt; \\] \\[ =a_1&lt;u_1,u_i&gt;+a_2&lt;u_2,u_i&gt;+\\cdots+a_n&lt;u_n,u_i&gt;=a_i \\] 应用 假如\\((x^0,x^1,x^2,...)\\)为\\(V\\)的一组基的话，我们就可以把任何一个函数写成\\(\\sum{a_ix^i}\\)的形式了，诶诶诶，这不就是我们想干的事嘛，用多项式来表示函数。 那么问题来了，我们该怎么求那个系数\\(a_i\\)？ 不妨假设，我们求出了一组单位正交基\\((u_1,u_2,\\ldots)\\)，对其中每个 \\(u_i\\)，它表示成\\(\\sum{a_ix^i}\\)形式的系数都是已知的，那我们岂不是可以先求出用\\((u_i)\\)表示的系数(利用刚才提到的内积)，再回代就可以得到用(\\(x_i\\))表示的系数。 那么我们只需要求正交基即可。 下面就直接给出算法了。 设已经有了一组单位正交基\\((u_1,u_2,\\ldots,u_n)\\)，\\(v\\)不能被\\((u_1,u_2,\\ldots,u_n)\\)表示，设 \\[ t=v-&lt;v,u_1&gt;-&lt;v,u_2&gt;-\\cdots-&lt;v,u_n&gt; \\] 则 \\[ u_{n+1}=\\frac{t}{||t||} \\] \\((u_1,u_2,\\ldots,u_n,u_{n+1})\\)的单位性与正交性很好验证。而且原来\\((u_1,u_2,\\ldots,u_n,v)\\)能表示出来的元素\\((u_1,u_2,\\ldots,u_n)\\)都能表示。 所以就完啦～ 例子 \\[ f(x)=sin(x) \\] 与 \\[ g(x)=0.987862x-0.155271x^3+0.00564312x^5 \\] 的函数图像画在一起,可以看到两者在\\((-\\pi,\\pi)\\)上十分重合。 粉色为\\(f(x)\\)，绿色为\\(g(x)\\) 我们仅需用很少的项就可以实现较高的精度。(比泰勒展开不知道高到哪里去了) 实现 有点丑，不过能用。(需开启C++11) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#include&lt;cmath&gt;#include&lt;complex&gt;using namespace std;typedef double db;typedef function&lt;double(double)&gt; func;typedef complex&lt;db&gt; C;const db eps=1e-10;const int N=1e6;db A,B; // 积分上下界struct poly_t &#123; db a[32];int deg; db operator()(db x) const&#123; db ret=0; for(int i=deg;i&gt;=0;i--) &#123; ret=ret*x+a[i]; &#125; return ret; &#125; void init() &#123; deg=0;fill(a,a+32,0); &#125; poly_t&amp; operator += (const poly_t &amp;o) &#123; deg=max(deg,o.deg); for(int i=0;i&lt;=deg;i++) a[i]+=o.a[i]; return *this; &#125; poly_t&amp; operator *= (db k) &#123; for(int i=0;i&lt;=deg;i++) a[i]*=k; return *this; &#125; poly_t&amp; operator /= (db k) &#123; *this*=1.0/k; return *this; &#125; poly_t&amp; operator -= (const poly_t &amp;o) &#123; deg=max(deg,o.deg); for(int i=0;i&lt;=deg;i++) a[i]-=o.a[i]; return *this; &#125; poly_t() &#123;init();&#125; void Print() &#123; for(int i=0;i&lt;=deg;i++) printf(\"%lf \",a[i]);puts(\"\"); &#125;&#125;;db calc(db l,db r,const func&amp; f) &#123; return (r-l)/6*(f(l)+4*f((l+r)/2)+f(r));&#125;db Simpson(db l,db r,const func&amp; f) &#123; db mid=(l+r)/2, left=calc(l,mid,f), right=calc(mid,r,f), whole=calc(l,r,f); if(fabs(left+right-whole)&gt;eps) return Simpson(l,mid,f)+Simpson(mid,r,f); else return whole;&#125;db InnerProduct(const func&amp; u,const func&amp; v) &#123; return Simpson(A,B,[u,v](db x)&#123;return u(x)*v(x);&#125;);&#125;poly_t base[6];int main() &#123; int i,j,k; const db Pi=3.1415926535897932384626433832795; db alpha; poly_t tt; A=-Pi;B=Pi; for(i=0;i&lt;6;i++) base[i].a[i]=1,base[i].deg=i; for(i=0;i&lt;6;i++) &#123; for(j=0;j&lt;i;j++) &#123; tt=base[j]; alpha=InnerProduct(tt,base[i]); tt*=alpha; base[i]-=tt; &#125; base[i]/=sqrt(InnerProduct(base[i],base[i])); &#125; poly_t ans; func origin=[](db x)&#123;return sin(x);&#125;; for(i=0;i&lt;6;i++) &#123; tt=base[i]; alpha=InnerProduct(origin,tt); tt*=alpha; ans+=tt; &#125; ans.Print();&#125;","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"https://jackpison.tk/categories/Mathematics/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://jackpison.tk/tags/数学/"},{"name":"线性代数","slug":"线性代数","permalink":"https://jackpison.tk/tags/线性代数/"},{"name":"多项式","slug":"多项式","permalink":"https://jackpison.tk/tags/多项式/"}]},{"title":"Hi Hexo","slug":"hi-hexo","date":"2018-01-13T16:00:00.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"uncategorized/hi-hexo/","link":"","permalink":"https://jackpison.tk/uncategorized/hi-hexo/","excerpt":"","text":"今天用Hexo搭了个博客，感觉挺好看的。 以后可能很多东西都会放在这里了，题解，学习资料之类的。 感觉还是自己弄的博客比较舒服。 希望大家常来看看。 新的一年要加油呢。","categories":[],"tags":[]},{"title":"NKOJ 3933 【贝壳串】 题解","slug":"shell-necklace-solution","date":"2018-01-13T06:46:20.000Z","updated":"2018-05-04T01:11:50.048Z","comments":true,"path":"Solution/shell-necklace-solution/","link":"","permalink":"https://jackpison.tk/Solution/shell-necklace-solution/","excerpt":"题目在此 给定每种长度的贝壳数量\\(A(i)\\)，求长度为\\(n\\)的链的种数。","text":"题目在此 给定每种长度的贝壳数量\\(A(i)\\)，求长度为\\(n\\)的链的种数。 设长度为\\(n\\)的链种数为\\(f(n)\\)，容易写出DP方程: \\(f(n)=\\sum_{i=1}^n{A(i)*f(n-i)}\\) 转移\\(O(n)\\)，直接计算复杂度\\((n^2)\\)，显然不可取。 注意到方程的卷积形式。设 \\(\\tilde{f}=\\sum{f(i)x^i}\\) \\(\\tilde{A}=\\sum{A(i)x^i}\\) 显然有\\(\\tilde{f}*\\tilde{A}+1=\\tilde{f}(mod~x^{n+1})\\) 解得\\(\\tilde{f}=\\frac{1}{1-\\tilde{A}}(mod~x^n)\\) 求逆即可。 这题的模数为313，于是巨坑。。 注意到多项式求时的迭代式。 \\(B_n(x)=B_m(x)*(2-B_m(x)*A_n(x))\\) \\(B_n(x)\\)中的系数可能达到\\(50000*313^3\\)的级别，会爆精度。。。 于是只好把\\(B_m(x)*A_n(x)\\)先算出来，再算\\(B_n(x)\\)，两次\\(FFT\\)以保证精度。 假如结果中的系数再鬼畜一点的话，就只能用拆系数\\(FFT\\)，这种黑科技了。 (然而没人写系列) Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;complex&gt;using namespace std;const int mod=313;const int N=5e5+5;typedef complex&lt;double&gt; C;const double Pi=3.1415926535897932384626433832795;C fft_wi[N],inv_wi[N];int max_exp;void init_wi(int n) &#123; int i,j,k; C t0=exp(C(0,Pi/n)), t1=exp(C(0,-Pi/n)); max_exp=n*2; fft_wi[0]=inv_wi[0]=1; for(i=1;i&lt;n;i++) &#123; fft_wi[i]=fft_wi[i-1]*t0; inv_wi[i]=inv_wi[i-1]*t1; &#125;&#125;void FFT(C A[],int n,int ty) &#123; int i,j,k,m,t,l; C *wi=ty==1?fft_wi:inv_wi; C t0,t1; for(j=i=0;i&lt;n;i++) &#123; if(i&lt;j) swap(A[i],A[j]); for(l=n&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); &#125; for(m=1;m&lt;n;m&lt;&lt;=1) &#123; t=max_exp/(m&lt;&lt;1); for(k=0;k&lt;n;k+=m&lt;&lt;1) &#123; for(i=k,j=0;i&lt;k+m;i++,j+=t) &#123; t0=A[i]; t1=A[i+m]*wi[j]; A[i]=t0+t1; A[i+m]=t0-t1; &#125; &#125; &#125; if(ty==1) return; t0=1.0/n; for(i=0;i&lt;n;i++) A[i]*=t0;&#125;C S[N],T[N];void polynomial_inverse(int A[],int B[],int len) &#123; if(len==1) &#123;B[0]=1;return;&#125; polynomial_inverse(A,B,len&gt;&gt;1); int i,j,k,M=len&lt;&lt;1; for(i=0;i&lt;len;i++) S[i]=A[i]; fill(S+len,S+M,0); for(i=0;i&lt;(len&gt;&gt;1);i++) T[i]=B[i]; fill(T+(len&gt;&gt;1),T+M,0); FFT(S,M,1);FFT(T,M,1); for(i=0;i&lt;M;i++) S[i]=S[i]*T[i]; FFT(S,M,-1); for(i=0;i&lt;M-(len&gt;&gt;1);i++) S[i].real(-((long long)floor(S[i].real()+0.5))%mod),S[i].imag(0); S[0].real((long long)floor(2-S[i].real()+0.5)%mod); fill(S+M-(len&gt;&gt;1),S+M,0); FFT(S,M,1); for(i=0;i&lt;M;i++) T[i]=T[i]*S[i]; FFT(T,M,-1); for(i=len&gt;&gt;1;i&lt;len;i++) B[i]=((long long)floor(T[i].real()+0.5))%mod; return;&#125;int n,M=1,A[N],B[N];int main() &#123; int i,j,k; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;A[i]),A[i]%=mod,A[i]=A[i]?mod-A[i]:0; A[0]=1;while(M&lt;=n) M&lt;&lt;=1;init_wi(M); polynomial_inverse(A,B,M); printf(\"%d\\n\",(B[n]+mod)%mod);&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://jackpison.tk/categories/Solution/"}],"tags":[{"name":"Solution","slug":"Solution","permalink":"https://jackpison.tk/tags/Solution/"},{"name":"FFT","slug":"FFT","permalink":"https://jackpison.tk/tags/FFT/"},{"name":"CDQ","slug":"CDQ","permalink":"https://jackpison.tk/tags/CDQ/"},{"name":"多项式求逆","slug":"多项式求逆","permalink":"https://jackpison.tk/tags/多项式求逆/"}]}]}